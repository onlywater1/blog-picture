# 数据结构 知识点

## 第一章 序幕

![第一章1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008407.png)

![第一章2](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008408.png)

![第一章3](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008409.png)

![第一章4](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008410.png)

## 第二章  线性表

![线性表1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008411.png)

![线性表2](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008412.png)

### 顺序表 静态分配

```c
#include<stdio.h>
#define MaxSize 10

//顺序表的定义  静态分配
//数组满了 就不能再分配了
typedef struct
{
	int data[MaxSize]; //数组长度
	int length; //顺序表当前的长度
}SqList;

//初始化顺序表
//c++写法  &L  修改顺序表 并将修改之后的结果带回去
void InitList(SqList& L)
{
	for (int i = 0; i < MaxSize; i++)
	{
		L.data[i] = 0; //每一个数据都初始化为0
	}
	L.length = 0;  //顺序表当前的长度初始化为0
 }
//插入元素
bool ListInsert(SqList& L, int i, int e)
{
	//判断插入位置是否合法
	if (i<1 || i>L.length + 1)
		return false;
	//判断存储空间是否已经满了
	if (L.length >= MaxSize)
		return false;
	//将第i之后的元素往后移
	for (int j = L.length; j>=i; j--)
	{
		L.data[j] = L.data[j - 1];
	}
	//将e赋值到i的位置上
	L.data[i - 1] = e;
	//线性表长度加1
	L.length++;
	return true;  //插入成功
}
//删除元素
bool ListDelete(SqList& L, int i, int& e)
{
	//判断删除位置的合法性
	if (i<1 || i>L.length)
		return false;
	e = L.data[i - 1];// 将删除的元素赋值给e
	//移动删除序号之后的元素
	for (int j = i; j < L.length; j++)
	{
		L.data[j - 1] = L.data[j];
	}
	//线性表的长度减1
	L.length--;
	return true;
}
//按位查找  查找i的数据
int GetElem(SqList L, int i)
{
	if (i<1 || i>L.length)
		return false;
	return L.data[i - 1];
}
//按值查找  找到返回下标
int LocateElem(SqList L, int e)
{
	for (int i = 0; i < L.length; i++)
	{
		if (L.data[i] == e)
			return i + 1;
	}
	//没找到返回0
	return 0;
}

//int main()
//{
//	//创建一个顺序表
//	SqList L;
//	//初始化操作
//	InitList(L);
//	//插入
//	ListInsert(L, 1, 2);
//	ListInsert(L, 2, 3);
//	//删除元素 并且将删除的元素带回来
//	int e = -1;
//	
//	if (ListDelete(L, 1, e))
//	{
//		printf("删除成功，删除的元素是%d\n", e);
//	}
//	else
//	{
//		printf("删除的为序不合法\n");
//	}
//	return 0;
//}
```

### 顺序表的动态分配

```c

#include<stdio.h>
#include<stdlib.h>
#define InitSize 10  //顺序表的初始化长度
//定义动态分配
typedef struct
{
	int* data;   //指示动态分配的指针
	int MaxSize; //顺序表的最大长度
	int length; //顺序表当前的长度
}SeqList;

//初始化动态顺序表
void InitList(SeqList& L)
{
	//分配空间 
	int* data = (int*)malloc(sizeof(int) * InitSize);
	L.MaxSize = InitSize; //最大长度 
	L.length = 0; //当前长度初始化为0

}
//增加顺序表的长度
void IncreaseSize(SeqList& L, int len)
{
	//使用p指针接收原来的顺序表的指针  用于数据的拷贝
	int* p = L.data;
	//输入要增加顺序表的长度  再次分配空间
	int* data = (int*)malloc(sizeof(int) * (InitSize + len));
	//将原来空间的数据拷贝到新的空间
	for (int i = 0; i < L.length; i++)
	{
		L.data[i] = p[i];
	}
	L.MaxSize = L.MaxSize + len; //修改最大长度
	free(p);  //释放掉旧的空间
}
//添加元素
bool IncreaseList(SeqList& L, int i, int e)
{
	if (i<1 || i>L.length)
	{
		return false;
	}
	if (L.length>=L.MaxSize)
	{
		printf("顺序表的长度以及达到最大，请申请内存后再次添加\n");
		return false;
	}
	for (int j = L.length; j >= i ; j--)
	{
		L.data[j] = L.data[j - 1];
	}
	L.data[i] = e;
	L.length++;
	return true;
}
//删除元素
bool ListDelete(SeqList& L, int i, int& e)
{
	if (i<1 || i>L.length)
		return false;
	e = L.data[i - 1];  //将删除的值返回
	for (int j = i; j < L.length; j++)
	{
		L.data[j - 1] = L.data[j];
	}
	L.length--;
	return true;
}

//int main()
//{
//	
//	SeqList L;
//	//初始化
//	InitList(L);
//	//增加顺序表的长度
//	IncreaseSize(L, 5);
//	return 0;
//}
```

### 链表

#### 1.静态链表

```c
#include<stdio.h>
#include<stdlib.h>
#define MaxSize 10 //静态链表的最大长度

//实现一个静态链表
typedef struct
{
	int data;  //静态链表存放数据
	int next;  //相当于静态链表的指针 指向下一个元素的下标  如果是最后一个元素 则为-1
}SLinkList[MaxSize];

int main()
{
	SLinkList a;  //声明一个静态链表

}

```



#### 2.不带头节点

```c
#include<stdio.h>
#include<stdlib.h>
//不带头节点

//单链表
typedef struct LNode
{
	int data; //存放数据
	struct LNode* next; //指向下一个节点的指针
}LNode,*LinkList;  //将struct LNode命名为LNode  
//将struct LNode* 命名为LinkList 
//LinkList 强调是一个单链表  
//LNode*  强调是一个节点

//初始化一个空的单链表  不带头节点
bool InitList(LinkList& L)
{
	L = NULL; //空表暂时没有任何节点
	return true;
}
//判断没有头节点的单链表是否为空
bool Empty(LinkList L)
{
	if (L == NULL)
		return true;
	else
		return false;
}
//按位插入元素
bool ListInsert(LinkList& L, int i, int e)
{
	if (i < 1)
		return false;
	//如果插入的节点是1 需要特殊处理
	if (i == 1)
	{
		LNode* s = (LNode*)malloc(sizeof(LNode));
		s->data = e;
		s->next = L;
		L = s;
		return true;
	}
	LNode* p; 
	int j = 1; //指向p指向的第几个节点  注意与带头节点的差别
	p = L; //p指向链表的第一个节点
	while (p != NULL && j < i - 1)
	{
		p = p->next;
		j++;
	}
	if (p == NULL)
		return false;
	LNode* s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true; //插入成功
}
```

#### 3.带头节点

```c
#include<stdio.h>
#include<stdlib.h>
//带头节点的单链表

//单链表
typedef struct LNode
{
	int data; //存放数据
	struct LNode* next; //指向下一个节点的指针
}LNode, * LinkList;  //将struct LNode命名为LNode  
//将struct LNode* 命名为LinkList 
//LinkList 强调是一个单链表  
//LNode*  强调是一个节点

//初始化一个空的单链表  带头节点
bool InitList(LinkList& L)
{
	L = (LNode*)malloc(sizeof(LNode)); //分配一个头节点
	if (L == NULL)
		return false;  //内存不足分配失败
	L->next = NULL;  //头节点之后暂时没有节点
	return true;
}
//判断有头节点的单链表是否为空
bool Empty(LinkList L)
{
	if (L->next == NULL)
		return true;
	else
		return false;
}
//按位序插入
bool ListInsert(LinkList& L, int i, int e)
{
	//插入的位置不可以小于1
	if (i < 1)
		return false;
	LNode* p; //指针p当前所指的节点
	int j = 0; //表面当前p指向第几个节点
	p = L; //p与L指向相同的节点
	while (p != NULL && j < i - 1)
	{
		p = p->next; //p继续往下找
		j++; //指向的元素加1
	}
	if (p == NULL)
		return false;  //i位置不合法
	LNode* s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;
}
//后插操作 在给定的节点后面插入元素
bool InsertNextNode(LNode* p, int e)
{
	if (p == NULL)
		return false;
	LNode* s = (LNode*)malloc(sizeof(LNode));
	if (s == NULL) //内存不足 分配空间失败
		return false;
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;
}
//前插操作
bool InsertPriorNode(LNode* p, int e)
{
	if (p == NULL)
		return false;
	LNode* s = (LNode*)malloc(sizeof(LNode));
	if (s == NULL) //内存不足 分配空间失败
		return false;
	s->next = p->next; 
	p->next = s; //将新节点s 连到 p之后
	s->data = p->data; //将p中元素赋值到s
	p->data = e;  //p中元素赋值为e
	return true;
}
//按位序删除
bool ListDelete(LinkList& L, int i, int &e)
{
	if (i < 1)
		return false;
	LNode* p;  //指向扫描的元素
	int j = 0; //指向扫描的第几个元素
	p = L; //p指向头节点
	//找到第i-1的元素
	while (p != NULL && j < i - 1)
	{
		p = p->next;
		j++;
	}
	//i 不合法
	if (p == NULL)
		return false;
	if (p->next == NULL) //p已经没有后继了
		return false;
	LNode* q = p->next;
	e = q->data; //将删除的元素返回
	p->next = q->next;
	free(q);
	return true;
}
//删除指定的元素
bool DeleteNode(LNode* p)
{
	if (p == NULL)
		return false;
	LNode* q = p->next;  //令q指向p的后继节点
	p->data = p->next->data; //将q的数据赋值到p
	p->next = q->next;  //将p的指针指向q的指针
	free(q);  // 释放掉存储空间
	return true;
}
//按位查找
LNode* GetItem(LinkList L, int i)
{
	if (i < 0)
		return NULL;
	LNode* p;
	int j = 0;  //p节点指向的第几个节点
	p = L; //L指向头节点 头节点是第0个节点 不存数据
	while (p != NULL && j < i)
	{
		p = p->next;
		j++;
	}
	return p;
}
//按值查找
LNode* LocateElem(LinkList& L, int e)
{
	//p指针指向头节点的下一个
	LNode* p = L->next;
	while (p != NULL && p->data != e)
	{
		p = p->next;
	}
	return p; //找到返回指针 否则返回null
}
//求表的长度
int Length(LinkList L)
{
	int len=0;  //记录表长
	LNode* p = L;
	while (p->next != NULL)
	{
		p = p->next;
		len++;
	}
	return len;

}
//尾插法 创建单链表
LinkList List_TailInsert(LinkList& L)
{
	int x; //定义一个变量记录输入的数值
	L = (LNode*)malloc(sizeof(LNode));  //初始化链表
	LNode* r = L;
	LNode* s = L; //定义两个指针指向头节点
	scanf("%d", &x); //输入要插入的数据
	while (x != 9999)
	{
		
		s = (LNode*)malloc(sizeof(LNode)); //申请新的节点存储插入的数据
		s->data = x;
		r->next = s;
		r = s; //将r指针与s指针指向相同的位置 r指针指向最后一位
		scanf("%d", &x);
	}
	r->next = NULL; //插入完成之后将尾节点的指针置为null
	return L;

}
//头插法
LinkList List_HeadInsert(LinkList& L)
{
	int x;
	LNode* s;
	L = (LNode*)malloc(sizeof(LNode)); //初始化一个单链表
	L->next = NULL;
	scanf("%d", &x);
	while (x != 9999)
	{
		s = (LNode*)malloc(sizeof(LNode)); //申请一个新节点存储插入的元素
		s->data = x;
		s->next = L->next; //将头节点的指针赋值给s
		L->next = s;//L指针指向s
		scanf("%d", &x);
	}
	return L;
}
```

#### 4.双链表

```c
//双链表
#include<stdio.h>
#include<stdlib.h>

typedef struct DNode
{
	int data;
	struct DNode* prior, * next;
}DNode,*DLinkList;

//初始化双链表
bool InitDlinkList(DLinkList& L)
{
	L = (DNode*)malloc(sizeof(DNode));
	if (L == NULL) //内存不足
		return false;
	L->next = NULL;
	L->prior = NULL;  //头节点的piror永远指向null
	return true;
}
//判断是否为空
bool Empty(DLinkList L)
{
	if (L->next == NULL)
		return true;
	else
	{
		return false;
	}
	
}
//双链表的插入  在p节点后面插入一个s节点
bool InsertNextNode(DNode*p,DNode *s)
{
	if (p == NULL || s == NULL) //p节点后者s节点给定错误
		return false;
	s->next = p->next; //将s节点的next指针指向p指针的next
	if (p->next != NULL) //如果p后面一个节点不是null 就修改piror指针指向s
		p->next->prior = s;
	s->prior = p;
	p->next = s;
	return true;

}
//删除p的后继节点
bool DeleteNextNode(DNode* p)
{
	if (p == NULL) return false; //p节点给定错误
	DNode* q = p->next;
	if (q == NULL) //查看q节点是不是不合法的
		return false;
	p->next = q->next; //修改p的next指针 指向q的next
	if (q->next != NULL)  //判断q是否有后继节点 有的话修改节点；
		q->next->prior = p;
	free(q); //释放空间
	return true;
}
//销毁一个双链表
bool DestoryList(DLinkList& L)
{
	while (L->next != NULL)  //如果L的后继节点不为空
		DeleteNextNode(L);  //调用函数 删除L的后继节点
	free(L);  //释放掉L
	return true;
}
```

## 第三章 栈

#### 栈的基本操作   

静态栈

```c
#include<stdio.h>
#define MaxSize 10
typedef struct
{
	int data[MaxSize];  //栈内存储的元素
	int top;  //栈顶指针  指向栈顶元素的位置 
}SqStack;


//初始化一个栈
void InitStack(SqStack& S)
{
	//让top指向-1
	S.top = -1;
	
}
//判断栈是否为空
bool Empty(SqStack S)
{
	if (S.top == -1)
		return true;
	else
	{
		return false;
	}
}

//新元素入栈
bool Push(SqStack& S, int e)
{
	//判断栈满没满
	if (S.top == MaxSize - 1)
		return false;
	S.top = S.top + 1;  //让top指针加1
	S.data[S.top] = e; //让元素放到栈顶
	return true;

}
//出栈
bool Pop(SqStack& S, int& e)
{
	//先判断栈是不是空
	if (S.top == -1)
	{
		return false;
	}
	e = S.data[S.top];  //栈顶元素出栈
	S.top -= 1;  //栈顶指针-1
	return true;

}
//读取栈顶元素
bool GetTop(SqStack S, int& e)
{
	//先判断栈是不是空的 
	if (S.top == -1)
		return false;
	e = S.data[S.top];  //返回栈顶的元素
	return true;

}


```

表达式求值问题

![表达式求值](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008413.png)

用计算的方法实现中缀转后缀

![image-20250310155319298](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008414.png)

中缀表达式的计算

![image-20250310160256124](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008415.png)

![image-20250310160430293](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008416.png)

#### 链栈

```c
#include<stdlib.h>
#include<stdio.h>

typedef struct Linknode
{
	int data;
	struct Linknode* next;

}LSnode,*LinkStack;

//初始化一个带头节点的链栈
bool  InitStack(LinkStack& LS)
{
	LS = (LSnode*)malloc(sizeof(LSnode));
	if (LS == NULL)
		return false;
	LS->next = NULL;
	return true;
}
//判断链栈是否为空
bool Empty(LinkStack LS)
{
	if (LS->next == NULL)
		return true;
	else
		return false;
}
//进栈
bool Push(LinkStack& LS, int e)
{
	LSnode* s = (LSnode*)malloc(sizeof(LSnode));
	s->data = e;
	s->next = LS->next;
	LS->next = s;
	return true;
}
//出栈
bool Pop(LinkStack& LS, int& e)
{
	if (LS->next == NULL)
		return false;
	LSnode* p = LS->next;
	e = p->data;
	LS->next = p->next;
	free(p);
	return true;
}
//读取栈顶元素
bool GetTop(LinkStack LS, int& e)
{
	if (LS->next == NULL)
		return false;
	e = LS->next->data;
	return true;

}
```

#### 用栈实现括号匹配

```c
//用栈实现括号的匹配操作
#define MaxSize 10
 
typedef struct
{
	int data[MaxSize];
	int top;
}SqStack;

//初始化栈
void  InitStack(SqStack &S)

//判断栈是否为空
bool IsEmpty(SqStack S)

//入栈 
bool Push(SqStack &S,int e)

//出栈
bool Pop(SqStack &S,int &e)

//括号匹配
bool CheckBrack(char str[], int length)
{
	SqStack S; 
	InitStack(S); //初始化一个栈
	for (int i = 0; i < length; i++)  //循环访问字符串
	{
		if (str[i] == '(' || str[i] == '[' || str[i] == '{')  //如果字符串的是一个右括号就压入栈
		{
			Push(S, str[i]);
		}
		else  //左括号栈就出栈
		{
			char topElem;
			Pop(S, topElem);
			if (str[i] == '(' && topElem != ')')  //判断括号是否匹配 不匹配就返回错误
				return false;
			if (str[i] == '[' && topElem != ']')
				return false;
			if (str[i] == '{' && topElem != '}')
				return false;
		}
	}
	return IsEmpty(S);  //扫描完成之后判断栈是不是空的
}
```

## 第四章 队列

### 静态队列

```c
#define MaxSize 10
//队列元素的个数 （rear+MaxSize-front）% MaxSize
//定义一个对列
typedef struct
{
	int data[MaxSize]; //存储对列元素
	int front, rear;  ///两个指针 一个指向队头一个指向队尾
}Squeue;

void  InitQueue(Squeue& Q)
{
	//让对头和队尾元素都指向0
	Q.front = 0;
	Q.rear = 0;
}
bool Empty(Squeue Q)
{
	//如果队尾指针等于队头指针 队列就为空
	if (Q.front == Q.rear)
		return true;
	else
		return false;
}
//入队
bool EnQueue(Squeue& Q, int e)
{
	//判断对列是否已满
	if ((Q.rear + 1) % MaxSize == Q.front)
		return false;
	Q.data[Q.rear] = e; //没满将e添加到尾部指针指向的位置
	Q.rear = (Q.rear + 1) % MaxSize;  //改变尾部指针指向的位置 相当于把队列看成一个环
	return true;
}
//出队
bool DeQueue(Squeue& Q, int& e)
{
	//先判断队列是否为空
	if (Q.front == Q.rear)
		return false;
	e = Q.data[Q.front];  //将front所指位置的元素返回
	Q.front = (Q.front + 1) % MaxSize; //改变front的位置
	return true;
}
//查找队头元素
bool GetHead(Squeue Q, int& e)
{

	//先判断队列是否为空
	if (Q.front == Q.rear)
		return false;
	e = Q.data[Q.front];  //将front所指位置的元素返回
	return true;
}
```

### 链式队列 

#### 带头结点

```c
#include<stdlib.h>

//定义一个链式的队列
typedef struct LinkNode
{
	int data;
	struct LinkNode* next;
}LinkNode;
//定义两个指针指向队头和队尾
typedef struct
{
	LinkNode* front;
	LinkNode* rear;
}LinkQueue;

//初始化一个队列
void InitQueue(LinkQueue& Q)
{
	//初始化front，rear都指向头节点
	Q.front = (LinkNode*)malloc(sizeof(LinkNode));
	Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next = NULL;

}
//判断是否为空
bool IsEmpty(LinkQueue Q)
{
	if (Q.front == Q.rear)
		return true;
	else
		return false;
}
//入队  只能在队尾入队
bool EnQueue(LinkQueue& Q, int e)
{
	LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
	if (s == NULL)
		return false;
	s->next = NULL; //s的指针指向null
	s->data = e;
	Q.rear->next = s; //插入的地方是尾部指针的下一个
	Q.rear = s;  //修改尾部指针的指向
	return true;
}
//出队 只能在队头出队
bool DeQueue(LinkQueue& Q, int& e)
{
	//判断队列是否为空
	if (Q.front == Q.rear)
		return false;
	LinkNode* p = Q.front->next; //申请一个指针指向对头元素的下一个
	e = p->data;  //把数据返回
	Q.front->next = p->next; //修改头节点的指针
	if (Q.rear == p) //如果删除的节点是最后一个节点需要修改尾节点
		Q.rear = Q.front;
	free(p); //释放空间
	return true;
}
```

#### 不带头结点

```c
#include<stdlib.h>

//定义一个不带头节点的链队
typedef struct LinkNode
{
	int data;
	struct LinkNode* next;
}LinkNode;
//定义两个指针指向队头和队尾
typedef struct
{
	LinkNode* front;
	LinkNode* rear;
}LinkQueue;

//初始化
void InitQueue(LinkQueue& Q)
{
	//不带头节点 将队列的头指针与尾指针都指向null
	Q.rear = NULL;
	Q.front = NULL;
}

//判断队列是否为空
bool IsEmpty(LinkQueue Q)
{
	if (Q.rear == NULL)
		return true;
	else
		return false;
}

//入队
bool EnQueue(LinkQueue& Q, int e)
{
	LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
	s->data = e;
	s->next = NULL;
	if (Q.front == NULL)  //插入的是第一个元素
	{
		Q.front = s;
		Q.rear = s;
	}
	else
	{
		Q.rear->next = s;  //不是第一个元素 在尾节点的后一个插入
		Q.rear = s; //修改尾指针的位置
	}
}
//出队
bool DeQueue(LinkQueue& Q, int& e)
{
	if (Q.front == NULL)  //判断队列是否为空
		return false;
	LinkNode* p = Q.front; //申请一个指针指向队头
	e = p->data;
	Q.front = p->next; //修改头指针的指向
	if (Q.rear == p) //如果删除的是尾指针指向的  将头指针与尾指针置为null
	{
		Q.rear = NULL;
		Q.front = NULL;
	}
	free(p);
	return true;
		
}
```

## 第五章 串

### 串的基本操作

```c
#include<stdio.h>
#define MaxSize 255  //最大存储容量

//定义一个字符串  定长的
typedef struct
{
	char ch[MaxSize];
	int length;  //字符串的实际长度
}SString;

//求字符串的长度
int StrLength(SString S)
{
	return S.length;
}


//取子串
bool SubString(SString& T, SString& S, int pos, int len)
{
	//判断给定的范围是否越界
	if (pos + len - 1 > S.length)
		return false;
	for (int i = pos; i < pos+len; i++)
	{
		T.ch[i - pos + 1] = S.ch[i];  //依次将指赋值到新的字符串  第0个不存储数据

	}
	T.length = len;  //修改字符串的长度
	return true;
}
//比较操作 比较两个字符串如果大返回大于0 如果小返回小于0 相等则为0
int StrCompare(SString S, SString T)
{
	//每一个字符串依次比较大小
	for (int i = 1; i <= T.length && i<=S.length; i++)
	{
		if (S.ch[i] != T.ch[i])
		{
			return S.ch[i] - T.ch[i];
		}
	}
	return S.length - T.length;  //字符都一样 字符串长度长的比较大
}
//查找子串在整个字符串的位置
bool index(SString S, SString T)
{
	int n, m;
	n = StrLength(S); //字符串的长度
	m = StrLength(T);  //子串的长度
	int i = 1;  //从第一个位序开始匹配 0是不用的
	SString sub;  //用于接收截取的子串
	while (i <= n - m + 1)  //依次进行截取子串
	{
		SubString(sub, S, i, m);
		if (StrCompare(sub, T) != 0) i++;  //截取之后比较字符串 如果不等于0 就是不相等
		else
			return i;  //找到返回字符的下标
	}
	return 0; //字符串中不存在子串
}
//朴素模式匹配
bool index1(SString S, SString T)
{
	int i = 1, int j = 1;  //表示开始对比的位置
	while (i <= S.length && j <= T.length)
	{
		if (S.ch[i] == T.ch[i])  //循环对比 如果相等就继续对比
			i++, j++;
		else
		{
			i = i - j + 2;  //不相等i的值变为下一个开始对比字符串的起始位序
			j = 1;  //j的值变为1
		}
	} 
	//如果循环完成之后j的值大于所要查找的字符串的长度查找成功 返回下标的位置
	if (j > T.length)
		return i - S.length;
	else
		return 0;  //没有匹配上


}
//kmp算法  传入一个数组 数组是当子串与主串不匹配时 子串的指针应返回的位置
int index_kmp(SString S, SString T, int next[])
{
	int i = 1;
	int j = 1;
	while (i <= S.length && j <= T.length)
	{
		if (j = 0 || S.ch[i] == T.ch[i])  //如果j=0 或者匹配上 说明两个串的指针该向前加1
		{
			++i;
			++j;
		}
		else {
			j = next[j];  //没有匹配上是只变换子串的指针
		}
	}
	if (j > T.length)  //循环结束之后判断一下长度  j大于子串的长度匹配成功
		return i - T.length;
	else
		return 0;
}
//获取next数组  自己举例子试一下
void get_next(SString T, int next[],int nextval[])
{
	int i = 1;
	int j = 0;
	next[1] = 0;  //数组的第一个永远是0
	while (i < T.length)
	{
		if (j == 0 || T.ch[i] == T.ch[j])
		{
			++i;
			++j;
			next[i] = j;
		}
		else
		{
			j = next[j];  //更换j的指向的位置
		}
	}
	//生成nextval数组
	//根据next写出nextval 判断取得next数组之后的字符与之前的字符是否相等
	// 相等则nextval数组变为next数组的下一个字符 不相等则不变 
	nextval[1] = 0;
	for (int p1 = 2; p1 < T.length; p1++)
	{
		if (T.ch[p1] == T.ch[next[p1]])
			nextval[p1] = nextval[next[p1]];
		else
		{
			nextval[p1] = next[p1];
		}
	}

}
```

kmp next数组

![image-20250311145644686](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008417.png)

![](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008418.png)

### 字符串创建

#### 动态创建

```c
#define MaxSize 255 
#include<stdlib.h>

//字符串的动态
typedef struct
{
	char* ch;  //指向字符串开始的位置
	int length;  //字符串的实际长度
}HString;

void InitString(HString& S)
{
	S.ch = (char*)malloc(sizeof(char));
	S.length = 0;

}
```

#### 使用链式存储字符串

```c
#include<stdlib.h>


//用链式存储实现字符串
typedef struct StringNode
{
	char ch[4];  //用数组来提高密度  提升空间的利用率
	struct StringNode* next;  //指向下一个字符
}StringNode,*String;
```





## 第六章 树

![image-20250311151937797](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008419.png)

![image-20250311152245772](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008420.png)

![image-20250311152531644](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008421.png)

![二叉树1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008422.png)

![二叉树的性质1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008423.png)

#### 完全二叉树的性质

![完全二叉树性质1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008424.png)

![完全二叉树性质2](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008425.png)

![完全二叉树性质3](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008426.png)

#### 根据遍历序列恢复二叉树

![根据序列恢复二叉树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008427.png)

#### 树的存储结构

![树的存储结构](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008429.png)

##### 双亲表示法

![双亲表示法](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008430.png)

##### 孩子表示法

![孩子表示法](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008431.png)

##### 孩子兄弟表示法

![孩子兄弟表示法](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008432.png)

##### 树与森林的转换

![森林和二叉树的转换](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008433.png)

##### 用链式存储的方式实现树的存储

```c

//链式存储的方式实现二叉树
#include<stdlib.h>
#include<stdio.h>
//二叉链表
typedef struct BiTNode
{
	int data;  //数据域
	struct BiTNode* lchild, * rchild;  //左孩子指针 右孩子指针
}BiTNode,*BiTree;
//链式队列 存储节点
typedef struct LinkNode
{
	BiTNode* data;
	struct LinkNode* next;
}LinkNode;
typedef struct
{
	LinkNode* front;
	LinkNode* rear;
}LinkQueue;
//初始化队列
void InitQueue(LinkQueue Q)
{
	Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next = NULL;
}
void  test()
{
	BiTree root = NULL;  //定义一个空树
	//插入一个节点
	root = (BiTNode*)malloc(sizeof(BiTNode));
	root->data = 1;
	root->lchild = NULL;
	root->rchild = NULL;


	//插入一个新节点
	BiTNode* p = (BiTNode*)malloc(sizeof(BiTNode));
	p->data = 2;
	p->lchild = NULL;
	p->rchild = NULL;
	root->lchild = p;  //根节点的左指针指向p
}
//打印数值
void visit(BiTree T)
{
	printf("%d ", T->data);
}
//先序遍历
void PreOrder(BiTree T)
{
	if (T != NULL)
	{
		visit(T); //根
		PreOrder(T->lchild); //左
		PreOrder(T->rchild);//右

	}
}
//中序遍历
void  InOrder(BiTree T)
{
	if (T != NULL)
	{
		InOrder(T->lchild);
		visit(T);
		InOrder(T->rchild);
	}
}
//后续遍历
void  PostOrder(BiTree T)
{
	if (T != NULL)
	{
		PostOrder(T->lchild);
		visit(T);
		PostOrder(T->rchild);
	}
}
//利用递归遍历求树的深度
int treeDepth(BiTree T)
{
	if (T == NULL)
		return 0;
	else
	{
		int l = treeDepth(T->lchild);
		int r = treeDepth(T->rchild);
		return l > r ? l + 1 : r + 1;
	}
}
//入队  只能在队尾入队
bool EnQueue(LinkQueue& Q, int e)
//出队 只能在队头出队
bool DeQueue(LinkQueue& Q, int& e)
//判断是否为空
bool IsEmpty(LinkQueue Q)
//树的层序遍历
void LevelOrder(BiTree T)
{
	LinkQueue Q; //利用队列辅助遍历
	InitQueue(Q);
	BiTree p;
	EnQueue(Q, T); //将根节点入队
	while (!IsEmpty(Q))  //队列非空的话
	{
		DeQueue(Q, p); //进行出队操作
		visit(p); //访问出队的节点 并将出队节点的左孩子与右孩子入队
		if (p->lchild != NULL)
			EnQueue(Q, p->lchild);
		if (p->rchild != NULL)
			EnQueue(Q, p->rchild);
	}

}
```

#### 线索化

![线索二叉树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008434.png)

##### 线索二叉树找前驱后继

![线索树找前驱后继总结](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008435.png)

##### 将二叉树线索化

```c
#include<stdio.h>
#include<stdlib.h>

//线索二叉树
typedef struct ThreadNode
{
	int data;  ///存放数据
	struct ThreadNode* lchild, * rchild;  //左孩子 有孩子
	int ltag,rtag; //一个标志位当tag=0是表示指向孩子，tag=1指向前驱或者后继
}ThreadNode,*ThreadTree; 

ThreadNode* pre;  //指向当前节点的前一个数据
//中序线索化二叉树
void CreatInThread(ThreadTree T)
{
	pre = NULL;  //将pre指针置为NULL
	if (T != NULL)
	{
		InThread(T);  //中序线索化二叉树
		//处理完全部指针之后 处理pre指针
		if(pre->rchild==NULL)
			pre->rtag = 1;
	}
}
//先序线索化
void PreThread(ThreadTree T)
{
	if (T != NULL)
	{
		visit(T);
		//先判断一下ltag是否为1
		if (T->ltag == 0)  //如果为0才进行线索化
			PreThread(T->lchild);
		PreThread(T->rchild);
	}
}

//中序遍历
void InThread(ThreadTree T)
{
	if (T != NULL)
	{
		InThread(T->lchild); //访问左节点
		visit(T);  //根节点
		InThread(T->rchild); //访问右节点
	}
}
//线索化
void visit(ThreadNode* q)
{
	if (q->lchild == NULL)  //左子树为空 建立前驱节点
	{
		q->lchild = pre;
		q->ltag = 1;
	}
	if (pre != NULL && pre->rchild) 
	{
		pre->rchild = q; //建立前驱节点的后继
		pre->rtag = 1;
	}
	pre = q;
}
//中序线索化如何如何查找后继
ThreadNode* FirstNode(ThreadNode* p)
{
	//以q节点为根节点第一次被访问的节点
	while (p->ltag == 0) p = p->lchild;
	return p;
}
//中序二叉树查找后续节点
ThreadNode* NextNode(ThreadNode* p)
{
	if (p->rtag == 0)  //p节点没有被线索化 查找p的后继 访问以p的右子节点为根的树
		return FirstNode(p->rchild);
	else
		return p->rchild; //被线索化直接返回p的右子节点
}
//对二叉线索树进行中序遍历
void InOrder(ThreadNode* T)
{
	for (ThreadNode* p = FirstNode(T); p != NULL; p = NextNode(p))
	{
		printf("%d ", T->data);
	}
}
//以p节点为中序遍历找到最后一个被遍历的节点
ThreadNode* LastNode(ThreadNode* p)
{
	//找到以p节点为根节点的右下的节点
	while (p->rtag == 0) p = p->rchild;
	return p;
}
ThreadNode* PreNode(ThreadNode* p)
{
	//根据标签判断前续
	if (p->ltag == 1) return LastNode(p->lchild);
	else
		return p->lchild;
}
```



#### 哈夫曼树

![image-20250311170350487](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008436.png)

![哈夫曼树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008437.png)

##### 哈夫曼编码

![哈夫曼编码](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008438.png)

![image-20250311171234427](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008439.png)

#### 树的遍历方式

![树-遍历方法对应](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008440.png)

## 特殊 并查集

![并查集](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008441.png)

```c
//并查集 双亲表示法
#define MAX_TREE_SIZE 14  //树中最多的节点
#define SIZE 13
//双亲表示法
typedef struct
{
	int data; //存放数据
	int parent; //指向双亲下标
}PTNode;
typedef struct  //树的定义
{
	PTNode node[MAX_TREE_SIZE];
	int n;  //树的节点数
}PTree;

int UFSets[SIZE];  //定义数据存储节点的双亲节点下标

//初始化
void InitSet(int S[])
{
	for (int i = 0; i < SIZE; i++)
	{
		S[i] = -1;
	}
}

//查找操作 x是下标
int Find(int S[], int x)
{
	while (S[x] > 0)  //循环找到x的根
		x = S[x];
	return x; //根的S[]小于0
}
//并  root为两个根的编号
void Union(int S[], int Root1, int Root2)
{
	if (Root1 == Root2)  return;
	//将Root2链接在root1下面
	S[Root2] = Root1;
}

//Union操作的优化 用根节点的下标的绝对值表示该数有多少个节点
//小树合并到大树
void Union1(int S[], int Root1, int Root2)  
{
	if (Root1 == Root2) return;
	if (S[Root2] > S[Root1])  //一节点的树更大 因为根节点的S[] 数值是负数
	{
		S[Root1] += S[Root2];  //修改大树的节点S[]
		S[Root2] = Root1; //小树合并到大树
	}
	else
	{
		S[Root2] += S[Root1];//修改大树的节点S[]
		S[Root1] = Root2;//小树合并到大树
	}
}
//find操作的优化 压缩路径
int Find1(int S[], int x)
{
	//循环找到根
	int root = x;
	while (S[root] > 0) root = S[root];
	//压缩路径
	while (x != root)
	{
		int t = S[x]; //用t存储x的父亲节点
		S[x] = root; //将x的父亲节点的指针指向根节点
		x = t; //修改x为他的父节点
	}
	return root; //返回根节点的编号
}
```



## 第七章 图

### 图的基本概念

![image-20250312143452138](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008442.png)

![图](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008443.png)

![image-20250312143239317](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008444.png)

![image-20250312143426151](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008445.png)

![image-20250312143656123](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008446.png)

![image-20250312143719118](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008447.png)

![image-20250312143830565](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008448.png)

![image-20250312144253145](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008449.png)

### 图的存储结构

![图的存储结构比较](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008450.png)

#### 邻接矩阵

![邻接矩阵的性质](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008451.png)

![邻接矩阵](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008452.png)

#### 邻接表

![邻接表](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008454.png)

#### 十字链表

![十字链表法1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008455.png)

#### 邻接多重表

![邻接多重表](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008456.png)

### 图的操作

  包括广度优先 深度优先 拓扑排序

![图的基本操作](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008457.png)

```c
//邻接矩阵
#define Maxvertexnum 100  //顶点的数目最大值
typedef struct
{
	char Vex[Maxvertexnum]; //顶点数目的最大值
	int Edge[Maxvertexnum][Maxvertexnum]; //邻接矩阵，边表
	int vexnum, arcnum; //图当前的顶点数和边数
}MGraph;


//邻接表
//顶点
typedef struct VNode
{
	int data;  //顶点信息
	ArcNode* first; //第一条边
}VNode,AdjList[Maxvertexnum];
//边
typedef struct ArcNode
{
	int adjex; //边指向哪一个顶点
	struct ArcNode* next; //指向下一个弧的指针
}ArcNode;
//用邻接表来存储图
typedef struct
{
	AdjList vertices;  //声明的数组
	int vexnum, arcnum; //这个图有多少顶点有多少条边
}ALGraph;

//找到第一个与顶点v相连的顶点
void  FirstNeighNode(Graph G, int v);
//找到除了v之外第一个与相连的顶点
void NextNeighbourNode(Graph G, int v, int w)

//广度优先遍历的升级版 防止非连通图的出现
void BFStraver(Graph G)
{
	//初始化辅助列表
	for (int i = 1; i < G.vexnum; i++)
	{
		visited[i] = false;
	}
	//遍历辅助队列查找谁还没被扫描
	for (int i = 1; i < G.vexnum; i++)
		if (!visited[i])  //没有被扫描的就以他为顶点开始进行深度优先遍历
			BFS(G, i);
}
//广度优先遍历
bool visited[Maxvertexnum];
void BFS(Graph G, int v)  //从顶点v开始遍历
{
	//使用一个辅助队列
	visit(v); //访问顶点v
	visited[v] = true; //将辅助队列v的值标记为true
	EnQueue(Q, v); //入队
	while (!isEmpty(Q)) //队列非空
	{
		DeQueue(Q, v); //出队
		for (w = FirstNeighNode(G, v); w >= 0; w = NextNeighbourNode(G, v, w))  //循环找到v的下一个节点以及除了下一个节点的下一个节点
			//找不到返回-1
		{
			if (!visited[w]) //判断找到的节点是否已经被访问
			{
				visit(w); //没有访问再次访问
				visited[w] = true; //修改标记
				EnQueue(Q, w); //入队
			}
		}
	}
}
//深度优先遍历的升级版 防止非连通图的出现
void DFStraver(Graph G)
{
	//初始化辅助列表
	for (int i = 1; i < G.vexnum; i++)
	{
		visited[i] = false;
	}
	//遍历辅助队列查找谁还没被扫描
	for (int i = 1; i < G.vexnum; i++)
		if (!visited[i])  //没有被扫描的就以他为顶点开始进行深度优先遍历
			DFS(G, i);
}
//深度优先遍历  v是顶点
void DFS(Graph G, int v)
{
	visit(v); //访问顶点
	visited[v] = true;  //将辅助数组标为true
	for (w = FirstNeighNode(G, v); w >= 0; w = NextNeighbourNode(G, v, w))  //查找节点
	{
		if (!visited[w])  //如果没有被访问
		{
			DFS(G, w);  //递归调用方法
		}
	}
	//print(v);   //用于实现逆拓扑排序
}
int d[Maxvertexnum];  //记录从一个初始点到现在点的距离
int path[Maxvertexnum]; //记录前一个点的序号
//广度优先的最小距离
void BFS_MiN_Distance(Graph G, int u)
{
	for (int i = 1; i < G.vexnum; i++)
	{
		//初始化数组
		d[i] = ∞; 
		path[i] = -1; 
	}
	d[u] = 0; //u节点的距离为0
	visited[u] = true; //辅助数组 标记已经访问
	EnQueue(Q, u); //入队
	while (!isEmpty(Q)) //队列非空
	{
		DeQueue(Q, u); //出队
		for (w = FirstNeighNode(G, u); w >= 0; w = NextNeighbourNode(G, u, w))  //循环找到没有被遍历的节点
		{
			if (!visited[w])
			{
				d[w] = d[u] + 1; //修改没有访问节点的距离
				path[w] = u;  //将path指向前一个节点
				visited[w] = true;
				EnQueue(Q, w); //入队
			}
			
		}
	}
	
}
//拓扑排序
bool TopologicalSort(Graph G)
{
	InitStack(S);  //初始化栈
	for (int i = 0; i < G.vexnum; i++)  //检索顶点 将入度为0的顶点入栈
	{
		if (indegree(i) == 0)
			Push(S, i);
	}
	int count = 0;  //用来记录出栈的顶点数
	while (isEmpty(S))  //如果栈非空
	{
		Pop(S, i); //出栈操作
		print[count++] = i; //修改出栈数组的信息 并且让count++
		for (p = G.vertices[i].firstarc; p; p = p->nextarc)  //循环找到出栈元素之后的节点
		{
			//将他们的入度减1
			v = p->adjvex;
			if (!(--indegree[v])) //将入度为0的顶点压入栈
				Push(S, v);
		}
	}
	if (count < G.vexnum) //判断出栈的顶点数量与图的顶点数量是否相同
		return false;
	else
		return true;
}
```

#### 图的广度优先

![图的广度优先遍历](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008458.png)

#### 图的深度优先

![图的深度优先遍历](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008459.png)

#### 图的拓扑排序

用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网（Activity On Vertex Network），简称AOV网。

![拓扑排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008460.png)

### 图的最小生成树

![image-20250312154044211](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008461.png)

![最小生成树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008462.png)

![image-20250312154732754](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008463.png)

### 图的距离算法

![图的距离算法总结](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008464.png)

#### 迪杰斯特拉

![迪杰斯特拉](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008465.png)

#### 弗洛伊德

![image-20250312160948928](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008466.png)

![floyd](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008467.png)

### 拓扑排序

![image-20250312173559634](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008468.png)

![image-20250312174246029](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008469.png)

![image-20250312174747016](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008470.png)

### 关键路径

![image-20250312174905612](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008471.png)

![image-20250312175114787](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008472.png)

![image-20250312175214317](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008473.png)

![关键路径1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008475.png)

![关键路径2](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008476.png)

在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图简称为AOE网。

![关键路径3](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008477.png)

关键路径求解



![关键路径求解](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008478.png)

## 第八章 查找

### 顺序查找

![顺序查找](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008479.png)

```c
typedef struct  //查找的数据结构（顺序表）
{
	int* elem;    //动态的数组基址
	int TableLen; //表的长度
}SSTable;
//顺序表的查找
int Search_order(SSTable ST, int key)
{
	int i;
	for (i = 0; i < ST.TableLen && ST.elem[i] != key; i++)
		return i == ST.TableLen ? -1 : i;  //
}
```

### 折半查找

![折半查找](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008480.png)

```c
typedef struct  //查找的数据结构（顺序表）
{
	int* elem;    //动态的数组基址
	int TableLen; //表的长度
}SSTable;
//折半查找  仅适合有序的顺序表
int Binary_search(SSTable ST, int key)
{
	int low = 0;
	int high = ST.TableLen - 1;
	int mid;
	while (low <= high)
	{
		mid = (low + high) / 2;
		if (ST.elem[mid] == key)
			return mid;
		else if (ST.elem[mid] < key)
			low = mid + 1;
		else
			high = mid - 1;
	}
	return -1; //没查到
}
```

### 分块查找

![分块查找](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008481.png)

### 二叉排序树

![image-20250313161112818](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008482.png)

![二叉排序树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008483.png)

```c
//二叉排序树  左子树小于根节点小于右子树
typedef struct BSTNode
{
	int key;
	struct BSTNode* lchild, * rchild;  //左右孩子
}BSTNode,*BiTree;
//二叉排序树中查找值为key的节点
BSTNode* BST_Search(BiTree T, int key)
{
	while (T != NULL && key != T->key)
	{
		if (key < T->key) //小于key 就找左子树
			T = T->lchild;
		else T = T->rchild; //大于找右子树
	}
	return T;
}
//二叉排序树用递归的方法实现
BSTNode* BSTSearch(BiTree T, int key)
{
	if (T == NULL)
		return NULL;
	if (key == T->key)
		return T;
	else if (key < T->key)
		return BSTSearch(T->lchild, key);
	else
	{
		return BSTSearch(T->rchild, key);
	}
	
}
//二叉树的插入  递归的方法
int BST_Insert(BiTree& T, int key)
{
	if (T == NULL)  //插入节点
	{
		T = (BiTree)malloc(sizeof(BSTNode));
		T->key = key;
		T->lchild = T->rchild = NULL;  //新节点的左右孩子指针指向null
		return 1;  //插入成功
	}
	else if (key == T->key)  //重复节点 插入失败
		return 0;
	else if (key < T->key)
		return BST_Insert(T->lchild, key); //插入到t的左子树
	else
		return BST_Insert(T->rchild, key); //插入到t的右子树
}
//构造一颗二叉树
void Creat_BST(BiTree& T, int str[], int n)
{
	T = NULL;  //构造一个空树
	int i = 0;
	while (i < n)
	{
		BST_Insert(T, str[i]);  //str 中的每一个数值插入到二叉树里面
		i++;
	}
}
```

### 平衡二叉树

![image-20250313162904902](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008484.png)

![平衡二叉树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008485.png)

![平衡二叉树1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008486.png)

#### 平衡二叉树的删除

![平衡二叉树的删除](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008487.png)

![平衡二叉树的删除1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008488.png)

![平衡二叉树的删除2](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008489.png)

### 红黑树

![image-20250313170415956](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008490.png)

![红黑树的定义](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008491.png)

![红黑树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008492.png)

![红黑树的插入](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008493.png)

![红黑树的删除](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008494.png)

![黑高推论](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008495.png)

### B树

![5叉查找树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008496.png)

![b树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008497.png)

![image-20250313180018854](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008498.png)

#### B树的插入

![b树的插入](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008499.png)

#### B树的删除

![b](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008500.png)

#### B树的高度  最大

![b树的高度](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008501.png)

#### 总结

![b树总结](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008502.png)

![b1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008503.png)

### B+树

![image-20250213103939108](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008504.png)

![b+树与b树的对比](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008505.png)

### 散列表

![image-20250213104145211](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008506.png)

![散列查找](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008507.png)

![散列查找成功](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008509.png)

![散列查找失败](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008510.png)

![散列表处理冲突的方法](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008511.png)

![image-20250313185413109](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008512.png)

![image-20250313185533721](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008513.png)

## 第九章 排序

### 插入排序

![插入排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008514.png)

```c
//插入排序
void InsertSort(int A[], int n)
{
	int i, j, temp;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1]) //如果后面的元素小于前面有序的最后一个节点
		{
			temp = A[i]; //将小的值用temp保存
			for (j = i - 1; j >= 0 && A[j] > temp; --j) //移动前面大于该节点的有序节点
			{
				A[j + 1] = A[j];
			}
			A[j + 1] = temp; //将小的节点插入到合适的位置
		}
	}
}
```

```c
//折半插入排序
void InsertSort1(int A[], int n)
{
	int i, j, low, high, mid;
	for (i = 2; i < n; i++) //依次将元素插入到已经拍好的序列中
	{
		A[0] = A[i]; //将要插入的元素先赋值到A[0]
		low = 1;
		high = i - 1;
		while (low <= high) //利用二分查找法查找插入的位置
		{
			mid = (low + high) / 2;
			if (A[mid] > A[0]) high = mid - 1;
			else low = mid + 1;
		}
		for (j = i - 1; j >= high + 1; --j) //插入的位置是high+1 将high+1-i-1的元素全部移动
		{
			A[j + 1] = A[j];
		}
		A[high + 1] = A[0];//将high+1的位置赋值插入的元素
	}
}
```

### 希尔排序

![希尔排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008515.png)

```c
//希尔排序（是插入排序的思想 实现部分有序 最后实现全部有序）
void ShellSort(int A[], int n)
{
	int i, j;
	for (int d = n / 2; d >= 1; d = d / 2) //步长的变化
	{
		for (i = d + 1; i <= n; i++)
		{
			if (A[i] < A[i - d]) //判断当前的指定的元素是否小于前一个相隔步长的元素
			{
				A[0] = A[i];
				for (j = i - d; j > 0 && A[j] > A[0]; j = j - d) //移动元素
					A[j + d] = A[j];
			}
			A[j + d] = A[0];//插入
		}
	}
}
```

### 冒泡排序

![冒泡排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008516.png)

```c
//冒泡排序
//交换函数
void swap(int& a, int& b)
{
	int temp = a;
	a = b;
	b = temp;
}
void BubbleSort1(int A[], int n)
{
	for (int i = 0; i < n - 1; i++)//循环的次数
	{
		bool flag = false;//标志位
		for (int j = n - 1; j > i; j--)//倒序进行交换 从尾开始
		{
			if (A[j - 1] > A[j])//如果前面的数值大于后面的就交换
			{
				swap(A[j - 1], A[j]);
				flag = true;
			}
				
		}
		if (flag == false)//一轮下来没有交换 提前结束冒泡排序
			return;
	}
}
//------------------------------------------------------------------------------------------------------
//正序冒泡
void BubbleSort2(int A[], int n)
{
	for (int i = 0; i < n - 1; i++) //循环的次数
	{
		bool flag = false;//标志位
		for (int j = 0; j < n - 1 - i; j++) //正序进行交换
		{
			if (A[j + 1] < A[j])//小的在左边
			{
				swap(A[j + 1], A[j]);
				flag = true;
			}
		}
		if (flag == false)
			return;
	}
}
```

### 快速排序

![快速排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008517.png)

```c
//快速排序
void QuickSort(int A[], int low, int high)
{
	if (low < high) //递归跳出的条件
	{
		int pivotpos = partition(A, low, high);//接收枢轴元素的位置
		QuickSort(A, low, pivotpos - 1);//处理枢轴的左半部分
		QuickSort(A, pivotpos + 1, high);//处理枢轴的右半部分
	}
}
//分区
int partition(int A[], int low, int high)
{
	int pivot = A[low]; //用low记录枢轴元素
	while (low < high) //用low 和high搜索枢轴元素的最终位置
	{
		while (low<high && A[high]>=pivot) --high; //high先移动 
		A[low] = A[high];//比枢轴小的都移动到左边
		while (low<high && A[low]<=pivot) ++low;
		A[high] = A[low];//比枢轴大的都移动到右边
	}
	A[low] = pivot;//枢轴元素存放的最终的位置
	return low;//返回枢轴元素的位置
}
```

### 选择排序

![选择排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008518.png)

```c
//选择排序
void SelectSort(int A[], int n)
{
	for (int i = 0; i < n - 1; i++) //循环次数
	{
		int min = i; //记录最小的元素的下标
		for (int j = i + 1; j < n; j++)//在A[i-n-1]中找最小的元素
		{
			if (A[j] < A[min]) min = j; //找到修改min
		}
		if (min != i) swap(A[i], A[min]);//如果min不等于i 交换两个元素
	}
}
```

### 堆排序

![image-20250314153105499](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008519.png)

![大根堆1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008520.png)

![image-20250314154645221](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008521.png)

![image-20250314154534982](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008522.png)

```c

//堆排序
//建立大根堆  len是表的长度
void BuildMaxHeap(int A[], int len)
{
	for (int i = len / 2; i > 0; i--)//从后往前调整大根堆
	{
		HeadAdjust(A, i, len); 
	}
}
//将以k位根建立大根堆
void HeadAdjust(int A[], int k, int len)
{
	A[0] = A[k]; //将当前节点复制到A[0]防止被覆盖
	for (int i = 2 * k; i <= len; i = i * 2) //调整大根堆
	{
		if (i < len && A[i] < A[i + 1]) //找出左右孩子哪一个数值比较大
			i++;
		if (A[0] > A[i]) break; //找出最大的孩子与A[0]相比更小的话调整结束
		else
		{
			A[k] = A[i]; //否则将A[i]的值调整到他的双亲节点上
			k = i; //将k指向他的最大的孩子节点的位置
		}
	}
	A[k] = A[0]; //最后将被筛选的节点放在最终的位置
}
//堆排序
void HeapSort(int A[], int len)
{
	BuildMaxHeap(A, len); //先建立大根堆
	for (int i = len; i > 1; i--) //进行i-1次排序  i指向的交换的元素的位置
	{
		swap(A[i], A[i]); //交换堆顶和堆底的元素
		HeadAdjust(A, 1, i - 1); //以堆顶元素为根调整大根堆
	}
}
```

![堆](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008523.png)

![堆排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008524.png)

堆和栈的区别

![image-20250308152514000](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008525.png)

![image-20250308152530411](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008526.png)

![image-20250308152544534](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008527.png)

### 归并排序

![归并排序思想](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008528.png)

![image-20250314161508910](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008529.png)

![归并排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008530.png)

```c
//归并排序
int len = 10;
int* B = (int*)malloc(sizeof(int) * len); //辅助队列
void Merge(int A[], int low, int mid, int high)
{
	int i, j, k; //3个指针 
	for (k = low; k <= high; k++) //将合并的数列复制到辅助队列里面
	{
		B[k] = A[k];
	}
	//合并两部分，第一部分是low到mid，第二部分mid+1到high
	for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++)
	{
		if (B[i] <= B[j])
			A[k] = B[i++];
		else
			A[k] = B[j++];
	}
	//将剩余的部分直接赋值到A数组
	while (i <= mid) A[k] = B[i++];
	while (j <= high) A[k] = B[j++];

}
void MergeSort(int A[], int low, int high)
{
	if (low < high)
	{
		int mid = (low + high) / 2;
		MergeSort(A, low, mid); //对于左半部分进行归并排序
		MergeSort(A, mid + 1, high); //对于右半部分进行归并排序
		Merge(A, low, mid, high); //归并
	}
}
```

### 基数排序

![image-20250314162206133](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008531.png)

![image-20250314162757099](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008532.png)

![image-20250314163008762](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008533.png)

### 外部排序

![image-20250216171014333](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008534.png)

![image-20250314163944106](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008535.png)

![image-20250314164406838](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008536.png)

![image-20250314164536954](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008537.png)

![外部排序](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008538.png)

![image-20250314164903785](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008539.png)

#### 外部排序的优化

减少比较次数

![image-20250314165555103](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008540.png)

增加归并路数 并且减少对比次数

![image-20250314165827252](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008541.png)

![败者树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008542.png)

![败者树1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008543.png)

![k路平衡归并](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008544.png)

置换选择排序  减少初始归并数量 并且不受限于内存工作区的大小

![置换选择排序1](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008545.png)

![置换选择排序2](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008546.png)

![置换选择排序总结](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008547.png)

最佳归并树 减少io的次数

每个小圆点代表着它占多少个磁盘块

![最佳归并树](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008548.png)

虚段的添加

![最佳归并树添加虚段的数量](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008549.png)

![最佳归并树总结](https://cdn.jsdelivr.net/gh/onlywater1/blog-picture/datastruct/202505231008550.png)
